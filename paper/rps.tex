% !TEX root = ethver.tex

\section{Case study: Rock-Paper-Scissors}

\subsection{Introduction}

In this section we present a case study of running EthVer on a real life example of a Rock-Paper-Scissors contract 
from \emph{Delmolino et al., Step by Step Towards Creating a Safe Smart Contract: Lessons and
Insights from a Cryptocurrency Lab} \cite{FCW:DAKMS16}. 
In this paper the authors describe smart contracts created by the attendees of a cryptocurrency course
for undergraduate students.
The authors document the typical mistakes student made and suggest ways to avoid them when designing 
a secure smart contract.

The Rock-Paper-Scissors is a protocol in which two players choose their inputs from $\{R, P, S\}$ and bet
$x$ ETH each. The reward of $2x$ goes to the winner according to the standard rules of the game or is split
between the players in case of a draw.
The students created an Ethereum contract code for this protocol and the authors pointed out the following
bugs in the code:
\begin{itemize}
\item if any player sends different amount of money than the fixed bet, his money is lost,
\item if any player joins the game as the third player, his money is also lost,
\item a malicious player can wait until his opponent makes his move and then he can get to know the opponent's
choice (since it is a publicly visible variable in the network) and make an according move, which guarantees him
a victory.
\end{itemize}
All of them are typical bugs that may arise during smart contract creation and they can be prevented by careful 
programming.
However, it turns out that EthVer could help the programmer
to find and correct every of these bugs automatically  and in this section we present a step by step analysis 
of the contract with EthVer which leads to the final, correct and secure version of the code.


%%%%%%%%%%%%%%%
\subsection{Original, buggy code of the contract}
%%%%%%%%%%%%%%%

\lstinputlisting[caption=RPS v1, label=lst:rps_v1]{../examples/rps_v1.etv}
%\begin{lstlisting}
%RPS v1
%\end{lstlisting}

Listing \ref{lst:rps_v1} depicts the original, buggy code of the Rock-Paper-Scissors contract.
It is written in a special EthVer input syntax which is similar to Solidity (a programming language for contracts
in Ethereum) enriched by some elements needed for PRISM verification like, e.g., bounded integer types.
This code can be passed as a source code to EthVer to generate a PRISM model for it which can be used
to verify PRISM properties.

In order to create the PRISM properties to verify, we must first define, what real properties are we expecting from
the model.
In the real Rock-Paper-Scissors game an honest player has 1/3 probability of winning, 1/3 probability of losing and
1/3 probability of a draw.
The protocol is modelled in PRISM as a Markov Decision Process (MDP) and PRISM allows us to verify
the \emph{minimum probability} and the \emph{maximum probability} properties, where the probability is taken 
over all random choices of the model and the minimum/maximum is taken over all the non-deterministic choices
of the model.
Therefore, we can construct the following PRISM properties to verify\footnote{here and later we omit the symmetric
properties for player 1}:
\begin{lstlisting}
Pmin=? [F endA & balance0 = 2]
Pmax=? [F endA & balance0 = 2]
Pmin=? [F endA & balance0 = 1]
Pmax=? [F endA & balance0 = 1]
Pmin=? [F endA & balance0 = 0]
Pmax=? [F endA & balance0 = 0]
\end{lstlisting}
All the properties above should evaluate to 1/3.
After we run the verification of these properties on the generated model in PRISM, it turns out that the properties
indeed evaluates to 1/3 each.
This means that in case of a game between two honest players, each of them has equal chances
of winning, losing and a draw.

In order to fully verify the correctness and security of a contract, we must consider a game between an honest
player and a malicious player and assure that the malicious player cannot increase his chances of winning or a draw.
This can be simplified to two properties for a game between an honest player 0 and a malicious player 1:
\begin{itemize}
\item the probability of winning by player 0 is at least equal to 1/3,
\item the probability of winning by player 0 or a draw is at least equal to 2/3.
\end{itemize}
These properties can be written as PRISM properties and then verified in the honest mode 
(\lstinline{ADVERSARY = -1}) and in the adversarial mode (\lstinline{ADVERSARY = 1}).
The results of the verification are shown in the table below:

\lstinputlisting[caption=Properties for RPS v1, label=prop:rps_v1]{../examples/rps_v1.props}

\begin{tabular}{|c|c|c|c|}
\hline
property & target & \shortstack{result \\ (honest mode)} & \shortstack{result \\ (adversarial mode)} \\
\hline
\lstinline{Pmin=? [F endA & balance0 >= 2]} & 1/3 & 1/3 & 0 \\
\hline
\lstinline{Pmin=? [F endA & balance0 >= 1]} & 2/3 & 2/3 & 0 \\
\hline
\end{tabular}

\subsection{Early interruption of the protocol}
We have seen that the contract code presented in the previous section is secure in the honest mode, however
it contains some bugs which make it vulnerable to attacks by the malicious player.
In order to find the bugs, we can start debugging RPS v1 with verifying if the final distribution of money corresponds 
to the chosen values 
of \lstinline{p0}, \lstinline{p1}.
PRISM provides a useful tool for generating a witness/counterexample for reachability properties.
In order to use it, we must formulate a reachability property describing an unwanted state, e.g., 
\textit{eventually, the player 0 finishes with no money
while the chosen values were the same}:
\begin{equation}
\text{\lstinline{E [F endA & balance0 = 0 & p0 = p1]}}
\label{prop:rps_v1_witness}
\end{equation}
This should never happen because \lstinline{p0 = p1} means that it is a draw, so player 0 should end up with
\lstinline{balance0 = 1}), so the property should evaluate to false.

If we verify the property in PRISM in \emph{honest mode} (\lstinline{ADVERSARY = -1}), it indeed evaluates to false.
However in \emph{adversarial mode} (\lstinline{ADVERSARY = 1}) the property evaluates to true and PRISM
generates a \emph{witness} --- the path to reach this undesirable state.
\img{rps_v1_witness}{The witness for property (\ref{prop:rps_v1_witness})}
Figure \ref{img:rps_v1_witness} shows the witness path.
A quick look on the functions being executed in the first 20 steps gives an immediate answer, what is wrong.
The order of function contract function executions is as follows:
\begin{itemize}
\item player 1 calls \lstinline{player_input}
\item player 0 calls \lstinline{finalize}
\item ...
\end{itemize}

Function \lstinline{finalize} is broadcast before player 0 has managed to broadcast his \lstinline{player_input} 
function call.
This is an obvious drawback of the contract --- calling \lstinline{finalize} function should not be allowed
before both \lstinline{player_input} functions have been executed.

\paragraph{Fix 1} 

The above flaw in the contract can be easily fixed by adding an additional condition at the beginning of the 
\lstinline{finalize} function:
\begin{lstlisting}
function finalize() {
  if (num_players == 2) {
    ...
\end{lstlisting}

After this fix we can rerun the verification.
It turns out that the property (1) is still satisfied, which means that the final distribution of money does not correspond
to the chosen values of \lstinline{p0} and \lstinline{p1}.
If we take a look at the witness generated by PRISM for this property, we will notice that this time
the critical path is as follows:
\begin{itemize}
\item player 0 calls \lstinline{player_input}
\item time step
\item player 1 calls \lstinline{finalize}
\item ...
\end{itemize}
The alarming thing is that \lstinline{time_step} occurs before \lstinline{broadcast_player_input1}.
It means that basically player 1 does not execute his \lstinline{player_input} step within the given time period.
This is another obvious flaw in the contract --- player 0 should not lose his money just because his opponent
didn't perform the required action on time.

\paragraph{Fix 2}

The shortcoming mentioned above can be fixed by adding a \emph{refund} possibility for the first player, if the second player
didn't join the game on time:
\begin{lstlisting}
function finalize() {
  if (time_elapsed > 0 && num_players == 1)
    player_address[0].send(BET);
  ...
\end{lstlisting}

After rerunning the verification we can see that this fix also does not solve the problem completely --- the property 
(\ref{prop:rps_v1_witness}) is still satisfied.
\img{rps_v1b_witness}{The witness for the property (\ref{prop:rps_v1_witness}) run on RPS v1 model after 
Fix 1 and Fix 2}
Now the verification generates another critical path:
\begin{itemize}
\item palyer 1 calls \lstinline{player_input}
\item palyer 1 calls \lstinline{player_input}
...
\end{itemize}
This emphasizes another drawback of the protocol:
a malicious player 1 can execute the \lstinline{player_input} function twice before player 0 joins the game.
This scenario is analogous to the situation in which two players joins the game and then player 0 tries to join
the game as a \textbf{third} one.
This cannot be prevented, since even if the cautious player checks the number of joined players before his move,
there still is a possibility that two players calls the \lstinline{player_input} function simultaneously.
In such case the decision on choosing the first function call to process depends on several random factors and the player
who joins last will lose his bet while staying outside the game.

\paragraph{Fix 3}

To mitigate the last problem, we can add another \emph{refund} mechanism to the \lstinline{player_input} function
which sends the bet back to the transaction sender, if the game is already full:
\begin{lstlisting}
function player_input() {
  if (num_players >= 2)
    msg.sender.send(msg.value);
  ...
\end{lstlisting}

The complete contract code after fixes 1, 2, 3 is depicted in listing \ref{lst:rps_v2} and will be referred to as RPS v2.

\lstinputlisting[caption=RPS v2, label=lst:rps_v2]{../examples/rps_v2.etv}
%\begin{lstlisting}[caption=RPS v2, label=lst:rps_v2]
%RPS v2
%\end{lstlisting}

%%%%%%%%%%%%%%%
\subsection{Cryptographic commitments}
%%%%%%%%%%%%%%%

After fixes 1, 2 and 3 the property (\ref{prop:rps_v1_witness}) is no longer satisfied.
This means that the problem of lack of connection between the chosen values and the final money distribution
has disappeared.
However, the properties from listing \ref{prop:rps_v1} still do not evaluate to the desired probabilities.

This time, the problem is more subtle.
In order to address it, we must take a closer look into how the transactions are being processed
in a blockchain-based system.
When a user calls a contract function, he creates a transaction, broadcasts it to a peer-to-peer network and 
eventually the transaction gets published in one of the upcoming blocks.
This in particular means that all the data contained in the transactions (like, e.g., arguments of function calls)
are publicly visible to all the network nodes and cannot be changed.
Thus, a malicious player in our Rock-Paper-Scissors game can wait until his opponent posts his move and 
the react with the appropriate move, which guarantees him a victory.

This feature of the blockchain-based system is reflected in a PRISM model checker in the following way.
Every variable in PRISM is \emph{public}, which means that once the value of a variable is set, it can influence
the non-deterministic choices of the next model steps.
In other words, after an honest player makes his move, its result is publicly known and the next, non-deterministic
moves of the malicious player can take advantage of this knowledge.
That is the reason why the properties from listing \ref{prop:rps_v1} evaluate to 0 --- in these properties we compute the
\emph{minimal probability}, and the minimum is taken over all the non-deterministic choices in the model.

The first line of defence against such pitfalls are the cryptographic commitments.
In order to prevent the chosen value from being visible to others, the value is chosen in secret and only
the commitment is published.
In real contract, the commitment is realized using a hash function --- a value $v$ and a random salt $s$ is chosen
in secret, then the hash $h = H(v, s)$ is computed and only $h$ is published.
In EthVer, commitments are implemented under special functions \lstinline{commit} and \lstinline{open} which
postpones the random choice of a value until the \emph{open} phase.

The Rock-Paper-Scissors code updated with the commitments is presented in listing \ref{lst:rps_v3}.

\lstinputlisting[caption=RPS v3, label=lst:rps_v3]{../examples/rps_v3.etv}
%\begin{lstlisting}[caption=RPS v3, label=lst:rps_v3]
%RPS v3
%\end{lstlisting}


%%%%%%%%%%%%%%%
\subsection{Misaligned incentives}
%%%%%%%%%%%%%%%

Even with cryptographic commitments implemented, the probabilities from listing \ref{prop:rps_v1} still evaluate to 0.
To find a bug we will once again use property (\ref{prop:rps_v1_witness}) to verify if the final distribution of money
corresponds to the chosen values of \lstinline{p0} and \lstinline{p1}.
It turns out that the property (\ref{prop:rps_v1_witness}) evaluates to true and PRISM provides us another witness 
for it. The crucial path this time is:
\begin{itemize}
\item player 0 calls \lstinline{player_input}
\item time step
\item player 1 calls \lstinline{player_input}
\item player 0 calls \lstinline{finalize}
\end{itemize}
In this scenario the player 1 does not join the game within a given time window.
We have already handled this situation in Fix 2, however this fix no longer works, because now the protocol
has 2 phases: \emph{commit} and \emph{open}.

If we look carefully at the interleaving above, we can see that the problem is
that the malicious player 1 can reject to call \lstinline{player_input} function on time, wait until player 0 starts
the \emph{refund procedure} and then call \lstinline{player_input} which potentially can be executed by the 
network before \lstinline{finalize}.
In such case the refund procedure from \lstinline{finalize} function fails, because at that time
\lstinline{num_players} is already equal to 2.

\paragraph{Fix 4}

One possible remedy for the problem mentioned above is to change the refund condition to:
\begin{lstlisting}
function finalize() {
  if (time_elapsed > 0 && committed0 && !committed1)
    player_address[0].send(BET);
  ...
\end{lstlisting}
and prohibit players from committing after the time step:
\begin{lstlisting}
function player_input() {
  if (num_players >= 2 || msg.value != 1 || time_elapsed > 0)
    msg.sender.send(msg.value);
  ...
\end{lstlisting}

This solves the problem described in the last paragraph, however after this fix the property 
(\ref{prop:rps_v1_witness}) is still satisfied, which means that another unwanted interleaving is possible.
This time the critical path looks as as follows:
\begin{itemize}
\item player 0 calls \lstinline{player_input}
\item player 1 calls \lstinline{player_input}
\item player 0 calls \lstinline{open}
\item time step
\item time step
\item player 0 calls \lstinline{finalize}
\end{itemize}

In this case both players join the game by executing the \lstinline{player_input} function and then only
player 0 opens his commitment on time.
This is a realistic scenario when a malicious player 1 waits until player 0 opens his commitment and then 
(knowing already the result of the game) refuses to open his commitment.

\paragraph{Fix 5}

To prevent from this behavior, we can introduce another refund mechanism, which transfers all the reward
to one player in case his opponent refuses to open his commitment within a given time frame (two timelock steps):
\begin{lstlisting}
function finalize() {
  if (time_elapsed > 1 && has_revealed0 && !has_revealed1) {
    player_address[0].send(reward);
  ...
\end{lstlisting}

\lstinputlisting{../examples/rps_v4.etv}
%\begin{lstlisting}[caption=RPS v4, label=lst:rps_v4]
%RPS v4
%\end{lstlisting}

\subsection{Final properties to verify}

Let's go back to our initial properties and verify the for the code after all the fixes:
\[
\begin{tabular}{|c|c|c|c|}
\hline
property & target & \shortstack{result \\ (honest mode)} & \shortstack{result \\ (adversarial mode)} \\
\hline
\lstinline{Pmin=? [F endA & balance0 >= 2]} & 1/3 & 1/3 & \textbf{0} \\
\hline
\lstinline{Pmin=? [F endA & balance0 >= 1]} & 2/3 & 2/3 & 2/3 \\
\hline
\end{tabular}
\]
We can see that the second property evaluates to the desired probability of 2/3, but the first property evaluates to 0.
Recall, that the first property can be read as \emph{player 0 wins with probability at least 1/3}.
The value of 0 follows from the fact, that player 1 can interrupt the protocol before sending any money to the contract.
In such case, the \emph{refund} mechanism pays back to player 0 only his own bet of value 1 and this is ok.
What we really want to verify is what is the minimal probability of winning of player 0 \emph{assuming that
both players have successfully joined the game}.
This can be expressed with a following PRISM property:
\[
\begin{tabular}{c}
\lstinline{filter(min, Pmin=? [ F balance0 >= 2 ], in_game0 & committed0} \\
\lstinline{ & committed1 & !has_revealed0 & !has_revealed1)},
\end{tabular}
\]
which can be read as \emph{what is the minimal probability of winning of player 0 assuming that player 0 is 
in the game, both players have been committed to their choices and none of the players have revealed their choice
yet}.\footnote{The \lstinline{filter(op, prop, states)} syntax of PRISM is used to verify property \lstinline{prop}
for all paths starting from set of initial states \lstinline{states} and return the result aggregated using \lstinline{op}
operator over all the paths.
The \lstinline{!has_revealed0} and \lstinline{!has_revealed1} conditions for initial states are necessary in order
to ensure that initial states the random choices are not yet done.
Otherwise the property will include the paths starting from the states after the choices are already done
and player 1 wins.}
This property indeed evaluates to 1/3, so after all the fixes we finally reached the version of contract which 
satisfies our initial conditions. 
The final set of properties and the results of verification are shown in the table below:
\[\begin{tabular}{|c|c|c|c|}
\hline
property & target & \shortstack{result \\ (honest mode)} & \shortstack{result \\ (adversarial mode)} \\
\hline
	\begin{tabular}{c}
		\lstinline{filter(min, Pmin=? [ F balance0 >= 2 ],} \\
		\lstinline{in_game0 & committed0 & committed1} \\
		\lstinline{& !has_revealed0 & !has_revealed1)}
	\end{tabular}
 	& 1/3 
	& 1/3 
	& 1/3 \\
\hline
\lstinline{Pmin=? [F endA & balance0 >= 1]} & 2/3 & 2/3 & 2/3 \\
\hline
\end{tabular}
\]
