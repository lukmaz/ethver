contract RPS {

	/* user: constants */
	uint BET = 100 finney;
	uint TIMEOUT = 10;
	
	/* auto: commitments */
	uint public choice0;
	uint public choice1;
	bytes32 public choice0_commitment;
	bytes32 public choice1_commitment;
	bool public choice0_committed = false;
	bool public choice1_committed = false;
	bool public choice0_revealed = false;
	bool public choice1_revealed = false;

	/* auto: timer */	
	uint public timer_start;

	/* user: variables */
	uint public num_players = 0;
	address public p0_address;
	address public p1_address;
	uint public reward = 0;
	bool public finalized = false;
	
	/* auto: functions results */
	bytes32 public hash_res;
	
	/* user: functions results */
	int public input_res;
	int public open_res;
	int public finalize_res;
	
	/* user: arrays */
	/* captures the rules of rock-paper-scissors game */
	int[3][3] public check_winner;
	
	
	function RPS() {
		/* auto: constant array initialization */
		/* If 2, tie
		   If 0, player 0 wins
		   If 1, player 1 wins
		   0 = rock
		   1 = paper
		   2 = scissors */
		check_winner[0][0] = 2;
		check_winner[1][1] = 2;
		check_winner[2][2] = 2;

		/* Rock beats scissors */
		check_winner[0][2] = 0;
		check_winner[2][0] = 1;

		/* Scissors beats paper */
		check_winner[2][1] = 0;
		check_winner[1][2] = 1;

		/* Paper beats rock */
		check_winner[1][0] = 0;
		check_winner[0][1] = 1;
	}
	
	/* auto const: workaround for converting address and choice from hex to string */
	function hash(address address_, uint choice, string nonce) returns (bytes32) {
		uint addr = uint(address_);
		byte[10] memory left_arr;
		byte[32] memory right_arr;
	    for (uint i = 0; i < 32; i++) {
	        uint x = uint(addr) % 16;
	        if (x < 10) 
	            right_arr[31-i] = byte(48 + x);
	        else
	            right_arr[31-i] = byte(97 + x - 10);
	        addr = addr / 16;
	    }
	    for (i = 0; i < 8; i++) {
	        x = uint (addr) % 16;
	        if (x < 10)
	            left_arr[9-i] = byte(48 + x);
	        else
	            left_arr[9-i] = byte(97 + x - 10);
	        addr = addr / 16;
	    }
   	    left_arr[0] = byte(48 + 0); /* 0 */
	    left_arr[1] = byte(120); /* x */
	    
	    uint l_uint = 0;
	    for (i = 0; i < 10; i++) {
	    	l_uint *= 256;
	    	l_uint += uint(left_arr[i]);
	    }
	    bytes10 left = bytes10(l_uint);

	    uint r_uint = 0;
	    for (i = 0; i < 32; i++) {
	    	r_uint *= 256;
	    	r_uint += uint(right_arr[i]);
	    }	
	    bytes32 right = bytes32(r_uint);
	    
	    hash_res = sha3(left, right, byte(48+choice), nonce);
		return hash_res;
	}
			
	/* adds players who send bid to the contract to the game */
	function player_input(bytes32 commitment) {
		if (num_players == 0 && msg.value >= BET) { 
			reward += msg.value;
			p0_address = msg.sender;
			choice0_commitment = commitment;
			choice0_committed = true;
			num_players++;
			if (msg.value - BET > 0) {
				msg.sender.send(msg.value - BET);
				reward -= msg.value - BET;
			}
			input_res = 0;
		}
		else if (num_players == 1 && msg.value >= BET) { 
			reward += msg.value;
			p1_address = msg.sender;
			choice1_commitment = commitment;
			choice1_committed = true;
			num_players++;
			if (msg.value - BET > 0) {
				msg.sender.send(msg.value - BET);
				reward -= msg.value - BET;
			}
			input_res = 0;
		}
		else {
			msg.sender.send(msg.value);
			input_res = -1;
		}
	}
	
	function open(uint choice, string nonce) {
		if (num_players != 2) {
			open_res = -1;
		}
		/* Determine which player is opening */
		if (msg.sender == p0_address) {
			/* Check the commitment is not yet opened */
			hash_res = hash(msg.sender, choice, nonce);
			if (hash_res == choice0_commitment
					&& !choice0_revealed) {
				/* Store opened value in plaintext */
				choice0 = choice;
				choice0_revealed = true;
				if (timer_start == 0) {
				    timer_start = block.number;
				}
				open_res = 0;
			}
			else {
				open_res = -1;
			}
		}
		else if (msg.sender == p1_address) {
			/* Check the commitment is not yet opened */
			hash_res = hash(msg.sender, choice, nonce);
			if (hash_res == choice1_commitment
					&& !choice1_revealed) {
				/* Store opened value in plaintext */
				choice1 = choice;
				choice1_revealed = true;
				if (timer_start == 0) {
				    timer_start = block.number;
				}
				open_res = 0;
			}
			else {
				open_res = -1;
			}
		}
		else {
			open_res = -1;
			return;
		}
	}

	function finalize() {
		if (!finalized) {
			if (block.number - timer_start < TIMEOUT) {
				finalize_res = -2;
				return;
			}
			
			/* Check if both players have revealed answer */
			if (choice0_revealed && choice1_revealed) {
				/* If player 0 wins */
				if (check_winner[choice0][choice1] == 0) {
					p0_address.send(reward);
					finalize_res = 0;
				}
				/* If player 1 wins */
				else if (check_winner[choice0][choice1] == 1) {
					p1_address.send(reward);
					finalize_res = 1;
				}
				/* If no one wins */
				else {
					p0_address.send(reward/2);
					p1_address.send(reward/2);
					finalize_res = 2;
				}
				finalized = true;
			}
			/* p1 has not revealed */
			else if (choice0_revealed && !choice1_revealed) {
				p0_address.send(reward);
				finalize_res = 0;
				finalized = true;
			}
			/* p0 has not revealed */
			else if (!choice0_revealed && choice1_revealed) {
				p1_address.send(reward);
				finalize_res = 1;
				finalized = true;
			}
			else {
				finalize_res = -1;
			}
		}
		else {
			finalize_res = -3;
		}
	}
}



// honest player scenario
random_int(3) choiceA
random_string nonceA = "nf31f09"
string commitmentA = "0x" + web3.sha3(my_address + choiceA + nonceA, true)

player_input(commitmentA, {from: alice, value: web3.toWei(100, "finney"), gas: 1000000})

// wait until second player is committed
while (!choice1_commited) {
	wait(1);
}

open.sendTransaction(choiceA, nonceA, {from: alice, value: 0, gas: 1000000})

// wait until second player opened his commitment
while (!choice1_revealed) {
	wait(1);
}

finalize({from: alice, value: 0, gas: 1000000})