// P1: ADV = -1
// P2: ADV = -1
// P3: ADV = 1
// P4: ADV = 0

user "U";
user "M";

CONTRACT_BALANCE_MAX = 1;
CONTRACT_BALANCE_INIT = 1;
USER_BALANCE_MAX = 1;
USER0_BALANCE_INIT = 0;
USER1_BALANCE_INIT = 0;
MAX_VALUE = 1;
MAX_TIME = 2;
//MAX_SIGNATURES = 3;
//MAX_COMMITMENTS = 2;

// c1, r1 - values in honest mode, recipient = 1
// c0, r0 - values in adversarial mode, recipient = 0
// rM - values from Merchant role of the protocol
// rU - values from User role of the protocol

contract Micropay {
  uint(2) pot = 1;
  uint(2) r1_loc;

  function_limit 2 release(cmt_uint(2) rel_r1, uint(2) rel_r2, hash rel_c) {
    r1_loc = valueOf(rel_r1);
    if ((pot > 0) && verCommitment(rel_r1, rel_c) && (r1_loc == rel_r2) &&
        verSig(0, comm_sigma, (rel_c, rel_r2, msg.sender))) {
      msg.sender.send(1);
      pot = pot - 1;
    }
  }
}    

communication {
  bool payment_requested;
  bool payment_issued;
  
  uint(2) comm_r2;
  hash comm_c;
  address comm_a;
  signature(cmt_uint(2), uint(2), uint(2)) comm_sigma;

  // function copy_commitment?

  function payment_request(hash req_c) {
    comm_c = req_c;
    comm_a = msg.sender;
    payment_requested = true;
  }

  function payment_issuance(hash iss_c, uint(2) iss_r2, uint(2) iss_a) {
    comm_r2 = iss_r2;
    comm_sigma = sign(iss_c, iss_r2, iss_a);
    payment_issued = true;
  }
  
}

scenario U {
  uint(2) r2;
  bool endU;

  wait(payment_requested, 1);
  // TODO: && time_elapsed < 1?
  if (payment_requested) {
    r2 = random(2);
    payment_issuance.sendCommunication(comm_c, r2, comm_a);
  }

  endU = true;
}

scenario M {
  cmt_uint(2) r1;
  uint(2) r1_val;
  bool winM;
  bool endM;

  r1.randomCommitment();

  payment_request.sendCommunication(hashOf(r1));
  wait(payment_issued, 1);
  if (payment_issued && time_elapsed < 1) {
    r1_val = valueOf(r1);
    if (r1_val == comm_r2) {
      winM = true;
      release.sendTransaction(r1, comm_r2, hashOf(r1), {from: "M", value: 0});
    }
  }
  endM = true;
}
