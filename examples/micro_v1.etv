// P1: ADV = -1
// P2: ADV = -1
// P3: ADV = 1
// P4: ADV = 0

user "U";
user "M";

CONTRACT_BALANCE_MAX = 1;
CONTRACT_BALANCE_INIT = 1;
USER_BALANCE_MAX = 1;
USER0_BALANCE_INIT = 0;
USER1_BALANCE_INIT = 0;
MAX_VALUE = 1;
MAX_TIME = 2;
MAX_SIGNATURES = 3;

// c1, r1 - values in honest mode, recipient = 1
// c0, r0 - values in adversarial mode, recipient = 0
// rM - values from Merchant role of the protocol
// rU - values from User role of the protocol

contract Micropay {
  uint(2) pot = 1;

  function release() {
    if (pot > 0 && is_signedU && has_revealedM && commitmentM == randU
        && ver(0, sigma, (commitmentM, randU, receiver))) {
      receiver.send(1);
      pot = pot - 1;
    }
  }
}    

communication {
  cmt_uint_signable(2) commitmentM;
  bool is_committedM;
  bool has_revealedM;
  bool is_signedU;
  uint_signable(2) randU;
  uint_signable(2) receiver;
  signature(3) sigma;

  function payment_request() {
    commitmentM.randomCommitment();
    is_committedM = true;
    receiver = msg.sender;
  }

  function payment_issuance(uint(2) r) {
    randU = r;
    is_signedU = true;
    sigma = sign(commitmentM, randU, receiver);
  }
  function open() {
    if (msg.sender == 1 && !has_revealedM) {
      commitmentM.openCommitment();
      has_revealedM = true;
    }
  }
}

scenario U {
  uint(2) rand0;
  bool endU;

  wait(is_committedM, 1);
  if (is_committedM) {
    rand0 = random(2);
    payment_issuance.sendCommunication(rand0);
  }

  endU = true;
}

scenario M {
  bool endM;

  payment_request.sendCommunication();
  wait(is_signedU, 1);
  if (is_signedU && time_elapsed < 1) {
    open.sendCommunication();
    if (commitmentM == randU) {
      release.sendTransaction({from: "M", value: 0});
    }
  }
  endM = true;
}
