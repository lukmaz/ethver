// P1: ADV = -1
// P2: ADV = -1
// P3: ADV = 1
// P4: ADV = 0

user "U";
user "M";

CONTRACT_BALANCE_MAX = 3;
CONTRACT_BALANCE_INIT = 3;
USER_BALANCE_MAX = 3;
USER0_BALANCE_INIT = 0;
USER1_BALANCE_INIT = 0;
MAX_VALUE = 1;
MAX_TIME = 2;
MAX_SIGNATURES = 3;
MAX_COMMITMENTS = 2;

// c1, r1 - values in honest mode, recipient = 1
// c0, r0 - values in adversarial mode, recipient = 0
// rM - values from Merchant role of the protocol
// rU - values from User role of the protocol

contract Micropay {
  uint(3) winning_tickets;
  uint(2) pot = 1;
  uint(3) deposit = 2;

  //function release(cmt_uint_signable(2) r1, uint_signable(2) r2, signature(3) s, uint_signable(2) a) {
  function release() {
    // adversary case:
    if (msg.sender == 0 && randU[0] == commitmentM[0]) {
      if (winning_tickets < 2) {
        winning_tickets = winning_tickets + 1;
      }
      if (pot > 0 && ver(0, sigma[0], (commitmentM[0], randU[0], receiver[0]))) {
        receiver[0].send(1);
        pot = pot - 1;
      }
    }
    // honest case:
    if (msg.sender == 1 && randU[0] == commitmentM[1]) {
      if (winning_tickets < 2) {
        winning_tickets = winning_tickets + 1;
      }
      if (pot > 0 && ver(0, sigma[0], (commitmentM[1], randU[0], receiver[1]))) {
        receiver[1].send(1);
        pot = pot - 1;
      }
    } 
  }

  function burn() {
    if ((winning_tickets >= 2) && (deposit >= 2)) {
      "null".send(2);
      deposit = deposit - 2;
    }
  }

  function release_deposit() {
    if (time_elapsed >= 2) {
      0.send(2);
      deposit = deposit - 2;
    }
  }
}    

communication {
  cmt_uint(2) commitmentM[2];
  bool is_committedM[2]; // wyluskac z commitmentu
  bool has_revealedM[2];
  bool is_signedU[0]; // wyluskac z podpisu
  uint(2) randU[2];
  uint(2) receiver[2];
  signature(3) sigma[2];

  function payment_request() {
    commitmentM[msg.sender].randomCommitment();
    is_committedM[msg.sender] = true;
    receiver[msg.sender] = msg.sender;
  }

  function payment_issuance(uint(2) pay_r) {
    randU[msg.sender] = pay_r;
    is_signedU[msg.sender] = true;
    sigma[msg.sender] = sign(commitmentM[msg.sender], randU[msg.sender], receiver[msg.sender]);
  }

  function open() {
    //if (msg.sender == 1 && !has_revealedM) {
    commitmentM[msg.sender].openCommitment();
    has_revealedM[msg.sender] = true;
    //}
  }
}

scenario U {
  uint(2) rand0;
  bool endU;

  wait(is_committedM[1], 1);
  if (is_committedM[1]) {
    rand0 = random(2);
    payment_issuance.sendCommunication(rand0);
  }
  wait(false, 2);
  release_deposit.sendTransaction({from: "U", value: 0});

  endU = true;
}

scenario M {
  bool endM;

  payment_request.sendCommunication();
  wait(is_signedU[0], 1);
  if (is_signedU[0] && time_elapsed < 1) {
    open.sendCommunication();
    if (commitmentM[1] == randU[0]) {
      //release.sendTransaction(commitmentM, randU, sigma, receiver, {from: "M", value: 0});
      release.sendTransaction({from: "M", value: 0});
      wait(balance1 >= 1, 1);
      if ((balance1 < 1) && (winning_tickets >= 2)) {
        burn.sendTransaction({from: "M", value: 0});
      }
    }
  }
  endM = true;
}
