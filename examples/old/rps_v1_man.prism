// Markov decision process (allows non-determinism)

mdp

const int MAX_BALANCE = 2;
const int NUM_STATES = 5;
const int BET = 1;
// TODO: zakresy
global num_players : [0..3] init 0;
global p0_address : [0..1];
global p1_address : [0..1];
global p0_choice : [0..2];
global p1_choice : [0..2];
global contract_balance : [0..MAX_BALANCE] init 0;
global reward : [0..MAX_BALANCE] init 0;
global finalized : bool init false;
global balanceAlice : [0..MAX_BALANCE] init BET;
global balanceBob : [0..MAX_BALANCE] init BET;

formula winner = (p0_choice = p1_choice) ? 2 :
	(
	 ((p0_choice = 0 & p1_choice = 2) |
	  (p0_choice = 2 & p1_choice = 1) |
	  (p0_choice = 1 & p1_choice = 0)) ? 1 : 2
	);

module playerA

	stateA : [1..NUM_STATES] init 1;
	valueA : [0..MAX_BALANCE] init BET;
	choiceA : [0..2] init 0;
	
	// normal random choice
	[] stateA = 1 & balanceAlice >= BET & contract_balance + BET <= MAX_BALANCE -> 
		1/3 : (stateA' = 2) & (balanceAlice' = balanceAlice - BET)
		  & (contract_balance' = contract_balance + BET) & (choiceA'=0)
		+ 1/3 : (stateA' = 2) & (balanceAlice' = balanceAlice - BET)
		  & (contract_balance' = contract_balance + BET) & (choiceA'=1)
		+ 1/3 : (stateA' = 2) & (balanceAlice' = balanceAlice - BET)
		  & (contract_balance' = contract_balance + BET) & (choiceA'=2);
		
	// first player
	[] stateA = 2 & valueA = BET & num_players = 0 & reward + valueA <= MAX_BALANCE ->
		(stateA' = 3) &
		(reward' = reward + valueA) &
		(p0_address' = 0) &
		(p0_choice' = choiceA) &
		(num_players' = num_players + 1);

	// second player
	[] stateA = 2 & valueA = BET & num_players = 1 & reward + valueA <= MAX_BALANCE ->
		(stateA' = 4) &
		(reward' = reward + valueA) &
		(p1_address' = 0) &
		(p1_choice' = choiceA) &
		(num_players' = num_players + 1);

	// wrong value
	[] stateA = 2 & valueA != BET ->
		(stateA' = 5);

	// waiting for second player
	[] stateA = 3 & finalized ->
		(stateA' = 5);

	// p0 wins and p0 is Alice
	[] stateA = 4 & winner = 0 & contract_balance - reward >= 0 & balanceAlice + reward <= MAX_BALANCE 
		& (p0_address = 0) -> 
		(stateA' = 5) &
		(finalized' = true) &
		(contract_balance' = contract_balance - reward) &
		(balanceAlice' = balanceAlice + reward);
	// p0 wins and p0 is Bob
	[] stateA = 4 & winner = 0 & contract_balance - reward >= 0 & balanceBob + reward <= MAX_BALANCE 
		& (p0_address = 1) -> 
		(stateA' = 5) &
		(finalized' = true) &
		(contract_balance' = contract_balance - reward) &
		(balanceBob' = balanceBob + reward);
	// p1 wins and p1 is Alice
	[] stateA = 4 & winner = 1 & contract_balance - reward >= 0 & balanceAlice + reward <= MAX_BALANCE 
		& (p1_address = 0) -> 
		(stateA' = 5) &
		(finalized' = true) &
		(contract_balance' = contract_balance - reward) &
		(balanceAlice' = balanceAlice + reward);
	// p1 wins and p1 is Bob
	[] stateA = 4 & winner = 1 & contract_balance - reward >= 0 & balanceBob + reward <= MAX_BALANCE 
		& (p1_address = 1) -> 
		(stateA' = 5) &
		(finalized' = true) &
		(contract_balance' = contract_balance - reward) &
		(balanceBob' = balanceBob + reward);
	// draw
	[] stateA = 4 & winner = 2 & contract_balance - reward >= 0 
			& balanceAlice + floor(reward/2) <= MAX_BALANCE 
			& balanceBob + floor(reward/2) <= MAX_BALANCE -> 
		(stateA' = 5) &
		(finalized' = true) &
		(contract_balance' = contract_balance - reward) &
		(balanceAlice' = balanceAlice + floor(reward/2)) &
		(balanceBob' = balanceBob + floor(reward/2));

endmodule

module playerB

	stateB : [1..NUM_STATES] init 1;
	valueB : [0..MAX_BALANCE] init BET;
	choiceB : [0..2] init 0;
	
	// probabilistic choice of choiceB
	//[] stateB = 1 & balanceBob >= BET & contract_balance + BET <= MAX_BALANCE -> 
	//	1/3 : (stateB' = 2) & (balanceBob' = balanceBob - BET) 
	//		& (contract_balance' = contract_balance + BET) & (choiceB' = 0)
	//	+ 1/3 : (stateB' = 2) & (balanceBob' = balanceBob - BET) 
	//		& (contract_balance' = contract_balance + BET) & (choiceB' = 1)
	//	+ 1/3 : (stateB' = 2) & (balanceBob' = balanceBob - BET) 
	//		& (contract_balance' = contract_balance + BET) & (choiceB' = 2);
	
	// non-deterministic choice of choiceB
	[] stateB = 1 & balanceBob >= BET & contract_balance + BET <= MAX_BALANCE ->
		(stateB' = 2) & (balanceBob' = balanceBob - BET)
		& (contract_balance' = contract_balance + BET) & (choiceB' = 0);
	[] stateB = 1 & balanceBob >= BET & contract_balance + BET <= MAX_BALANCE ->
		(stateB' = 2) & (balanceBob' = balanceBob - BET)
		& (contract_balance' = contract_balance + BET) & (choiceB' = 1);
	[] stateB = 1 & balanceBob >= BET & contract_balance + BET <= MAX_BALANCE ->
		(stateB' = 2) & (balanceBob' = balanceBob - BET)
		& (contract_balance' = contract_balance + BET) & (choiceB' = 2);
	
	// first player
	[] stateB = 2 & valueB = BET & num_players = 0 & reward + valueB <= MAX_BALANCE ->
		(stateB' = 3) &
		(reward' = reward + valueB) &
		(p0_address' = 1) &
		(p0_choice' = choiceB) &
		(num_players' = num_players + 1);
	// second player
	[] stateB = 2 & valueB = BET & num_players = 1 & reward + valueB <= MAX_BALANCE ->
		(stateB' = 4) &
		(reward' = reward + valueB) &
		(p1_address' = 1) &
		(p1_choice' = choiceB) &
		(num_players' = num_players + 1);
	// wrong value
	[] stateB = 2 & valueB != BET ->
		(stateB' = 5);
	
	// waiting for second player
	[] stateB = 3 & finalized ->
		(stateB' = 5);

	// p0 wins and p0 is Alice
	[] stateB = 4 & winner = 0 & contract_balance - reward >= 0 & balanceAlice + reward <= MAX_BALANCE 
		& p0_address = 0 -> 
		(stateB' = 5) &
		(finalized' = true) &
		(contract_balance' = contract_balance - reward) &
		(balanceAlice' = balanceAlice + reward);
	// p0 wins and p0 is Bob
	[] stateB = 4 & winner = 0 & contract_balance - reward >= 0 & balanceBob + reward <= MAX_BALANCE 
		& p0_address = 1 -> 
		(stateB' = 5) &
		(finalized' = true) &
		(contract_balance' = contract_balance - reward) &
		(balanceBob' = balanceBob + reward);
	// p1 wins and p1 is Alice
	[] stateB = 4 & winner = 1 & contract_balance - reward >= 0 & balanceAlice + reward <= MAX_BALANCE 
		& p1_address = 0 -> 
		(stateB' = 5) &
		(finalized' = true) &
		(contract_balance' = contract_balance - reward) &
		(balanceAlice' = balanceAlice + reward);
	// p1 wins and p1 is Bob
	[] stateB = 4 & winner = 1 & contract_balance - reward >= 0 & balanceBob + reward <= MAX_BALANCE 
		& p1_address = 1 -> 
		(stateB' = 5) &
		(finalized' = true) &
		(contract_balance' = contract_balance - reward) &
		(balanceBob' = balanceBob + reward);
	// draw
	[] stateB = 4 & winner = 2 & contract_balance - reward >= 0 
			& balanceAlice + floor(reward/2) <= MAX_BALANCE 
			& balanceBob + floor(reward/2) <= MAX_BALANCE ->
		(stateB' = 5) &
		(finalized' = true) &
		(contract_balance' = contract_balance - reward) &
		(balanceAlice' = balanceAlice + floor(reward/2)) &
		(balanceBob' = balanceBob + floor(reward/2));

endmodule

// labels
label "Alice_win" = (stateA = 5 & stateB = 5 & balanceAlice = 2 * BET); 
label "Bob_win" = (stateA = 5 & stateB = 5 & balanceBob = 2 * BET);
label "draw" = (stateA = 5 & stateB = 5 & balanceAlice = BET & balanceBob = BET);
