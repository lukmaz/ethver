contract RPS {
  user "A";
  user "B";

  uint(10) products_sent;

  uint(3) randU[2];
  uint(3) randM[2];

  random_uint(3) commit[2];
  uint(2) is_committed[2];
  uint(2) is_signed[2];

  function ask_payment(random_uint(3) c) {
    commit[msg.sender] = c;
    is_committed[msg.sender] = 1;
    is_signed[msg.sender] = 0;
  }

  function send_ticket(uint(2) merchant, uint(3) r) {
    if (msg.sender == "A") {
      if (is_committed[merchant] == 1) {
        if (is_signed[merchant] == 0) {
          randU[merchant] = r;
          is_signed[merchant] = 1;
        }
      }
    }
  }

  function get_payment(uint(2) reveal) {
    if (reveal == 1) {
      if (is_signed[msg.sender] == 1) {
        if (commit[msg.sender] == 3) {  //special value
          randM[msg.sender] = random(3);
        }
        if (commit[msg.sender] != 3) {  //special value
          randM[msg.sender] = commit[msg.sender];
        }
        if (randM[msg.sender] == randU[msg.sender]) {
          msg.sender.send(1);  // TODO: Czy to zadziała?
        }
        is_committed[msg.sender] = 0;
        is_signed[msg.sender] = 0;
      }
    }
  }

}


scenario A {
  
  uint(3) r0;
  r0 = random(3);
  //TODO: jak będzie wait osobno, to może zadziała is_committed[1]
  send_ticket.sendTransaction(1, r0, {from: "A", value: 0, wait: (is_committed_1 == 1)});
  
}

scenario B {
  random_uint(3) r1;
  r1 = random_lazy(3);
  ask_payment.sendTransaction(r1, {from: "B", value: 0});
  // TODOL: zrobić wait osobno, żeby zadziałało is_signed[1]
  get_payment.sendTransaction(1, {from: "B", value: 0, wait: (is_signed_1 == 1)});
}

